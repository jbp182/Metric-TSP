// traveling salesperson problem 
// minimize constraint violations
// neighbourhood - 2opt

import cotls;
include "file_io";


string dtestname = "../TP1-MetricTSP/tests/";
string dseedname = "../TP1-MetricTSP/seeds/";
string fname = "test_100_100_0.txt";
string prev = "greedy";   //"christofides";
string initial_sol = "0 38 81 37 21 71 36 72 13 22 33 39 69 35 66 79 19 67 1 56 88 53 6 26 84 45 32 54 44 28 55 47 95 34 73 10 41 63 40 64 46 75 74 68 25 60 77 59 9 86 43 42 57 12 15 92 29 96 65 83 2 20 94 31 48 78 61 87 3 80 70 30 91 89 14 90 49 58 17 4 98 16 50 5 18 97 82 76 51 8 62 24 7 99 27 23 11 85 93 52 ";

/////////////////////////////////////
/////////////////////////////////////

int[,] mat = readMatGraph(dtestname+fname);
int n = mat.getSize(0);
range Nodes = 1..n;
int huge = 1000;
int graph[Nodes,Nodes];
forall(i in Nodes, j in Nodes: i!= j) 
   if(mat[i,j] == 0) graph[i,j] = huge; else graph[i,j] = mat[i,j];

printMat(graph);

cout << " starting" << endl;
string[] initial = initial_sol.split(" ");
int seed[Nodes];
forall(i in Nodes)
   seed[i] = initial[i].toInt();
forall(i in Nodes) cout << seed[i] << " " ;

function int swap_2opt(ConstraintSystem<LS> D, var{int}[] rank, var{int}[] test, int i, int j){
   int n = rank.getSize();
   forall(k in 1..i-1) test[k] := rank[k];
   forall(k in j+1..n-1) test[k] := rank[k];
   forall(k in i..j) test[k] := rank[i + j-k];
   return D.violations();

}

range Enodes = 1..n+1;
range Inodes = 2..n;
range numTests = 1..100;

int solutions[numTests];
int best_sol = System.getMAXINT();
int sum_all = 0;



/*
forall(times in numTests) {
   RandomPermutation perm(Inodes);

   Solver<LS> ls();
      var{int} rank[i in Enodes](ls,Nodes) := 1;
      forall(i in Inodes) rank[i] := perm.get();
      var{int} test[i in Enodes](ls,Nodes) := rank[i];
   
      ConstraintSystem<LS> D(ls);                                         // equivalent to Function T
         forall(i in Nodes)
            D.post(0 == graph[test[i],test[i%n+1]]);

   ls.close();


   int tabuDuration = 3;
   int tabu[Nodes, Nodes] = 0;

   int best_so_far = D.violations();
   int it_best;
   int x;
   cout << "starting with " << rank << endl;
   cout << "cost: " << best_so_far << endl;

   int it = 0;
   while(best_so_far > 0 && it < n){
      selectMin(i in Inodes, j in Inodes: j > i+1 && tabu[i,j] < it, v = swap_2opt(D, rank, test, i, j)) (v) {
         tabu[i,j] = tabu[i,j] + tabuDuration;
         tabu[j,i] = tabu[j,i] + tabuDuration;
         if (v < best_so_far) {
            it_best = it;
            best_so_far = v;
            x = swap_2opt(D, rank, test, i, j);
            forall(i in Inodes) rank[i] := test[i];
         }
      }
      it++;
   }

   forall(i in Inodes) test[i] := rank[i];

   int current = D.violations();
   cout << endl;
   cout << " --- LS solution (min Viols) to " << fname << endl;
   cout << " best solution (found at iteration " << it_best << "):" << endl;
   cout << " ------ " << rank << endl;
   cout << "      with cost: " << current << endl;

   solutions[times] = current;
   if (current < best_sol)
      best_sol = current;
   sum_all += current;
}

cout << endl;
forall(i in numTests)
   cout << solutions[i] << " ";
cout << endl;
cout << "best_sol: " << best_sol << endl;
int avg = sum_all / numTests.getUp();
cout << "avg: " << avg << endl;*/